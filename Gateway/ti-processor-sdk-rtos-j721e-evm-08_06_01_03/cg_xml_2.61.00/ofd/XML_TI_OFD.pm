#=============================================================================
# POD Documentation First ...
#=============================================================================

# This code is released under a license detailed at the end of this file.

=head1 NAME

XML_TI_OFD.pm

=head1 SYNOPSIS

Perl module for converting XML files generated by TI OFD utilities into
Perl data structures

=head1 USAGE

   use XML_TI_OFD;                               # don't check version

OR ...

   use XML_TI_OFD 3.10;                          # check module version

The second form insures you are picking up the module version 3.10 or later.

=head1 LIMITATIONS

This is an alpha version of capability for processing ELF files.  Only
fully linked .out files have been tested as input.  Other types of ELF files
such as unlinked .obj files, library files, dynamically linked files, have
NOT been tested.

=head1 DESCRIPTION

OFD stands for Object File Display utility.  Examples include ofd6x for 
C6000 and ofd55 for C5500.  This utility outputs information about TI object
files, or libraries of TI object files.  This utility can output this
information in XML format with the -x option.  Use this module to turn that
XML data into far more useful Perl data structures.  

This module should be delivered with at least one example usage file
"dump_ofd.pl".  Start by using and exploring that script.  All it does
is read in the XML file and dump out the resulting Perl data structures.
Understanding those data structures is key to implementing any further
object file post-processing routines.

=head1 FUNCTIONS EXPORTED BY DEFAULT

The most commonly used functions in the module.

=head2 ofd_process_xml_file

Input: Name of the XML file, or a string that holds all the XML

Returns: Reference to data structure representing XML tree

Main entry point to the module.

=head2 ofd_find_lib_name

Input:   Reference to Perl data structure returned by ofd_process_xml_file

Returns: Name of the library, if it exists.  undef otherwise.

The main way to check if input file is a library or not.

=head2 ofd_get_input_file_name

Input:   Reference to Perl data structure returned by ofd_process_xml_file

Returns: The name of the input object file or library used to build the XML
information.

=head2 ofd_each_file

Input:   Reference to Perl data structure returned by ofd_process_xml_file

Returns: Array of references, one per file in the XML data structure

It doesn't matter whether the underlying data structure came from a library
or a single .obj/.out file.  Typical usage ...

       $xml_data = ofd_process_xml_file($file_name);
       if ($lib_name = ofd_find_lib_name($xml_data))
       {
          print "Processing library $lib_name ...";
       }
  
       foreach $file_data (ofd_each_file($xml_data))
       {
          print "Processing file $file_data->{'name'} ...";
          process_file($file_data);
       }   
  
Note that if the underlying file is not a library, a library name will
not be printed, and the foreach loop will execute only once.
  
If you just want the first file no matter how many there may be ...
 
       @file_list = ofd_each_file($xml_data);
       $file_data = $file_list[0];

=head2 ofd_each_section

Input: An element from an array returned by ofd_each_file

Returns: Array of references, one per section in the file

Typical usage:

        foreach $file_data (ofd_each_file($xml_data))
        {
           foreach $sect_data (ofd_each_section($file_data))
           {
              ...
           }
        }   

=head2 ofd_each_symbol

Input: An element from an array returned by ofd_each_file

Returns: Array of references, one per symbol in the file

Typical usage:

        foreach $file_data (ofd_each_file($xml_data))
        {
           foreach $symbol_data (ofd_each_symbol($file_data))
           {
              ...
           }
        }   

=head2 ofd_each_die_entry

Input: A compile_unit reference from the dwarf data

Returns: Array of references, one per DIE entry

Typical usage:

        foreach my $die_tag (ofd_each_die_entry($compile_unit)) {
           ...
        }   

DIE entries can be at 2 different levels hence the need for a function in
this module to abstract such details. Object files (and .out's linked
with -b to disable type merging) have an extra level {'die'}->[0]->{'die'}
compared to standard TI out files {'die'} for their type information.
XML can only be represented by 1 or the other so check for which & return it.

=head2 ofd_filter_xml

 Input: - Name of the XML file, or undef if passing a string
        - Reference to a string
        - A hash of arguments described below

 Returns: Nothing directly.  String is returned via ref (2nd argument).

The XML files created by OFD can be very large, especially if the -g option
is used to include the Dwarf information.  Files in the tens of megabytes
are common.  Use this function to filter the XML file, keeping only the
parts you specify, thus making the rest of your script run much faster.

Using this function is not required for correctness.  It only affects
execution speed.

The 2nd argument is a reference to a string.  If no filename is passed, then
this string is the input to be stripped.   It is assigned all the lines from
the stripped down XML file.  This string (not a reference to it) can be passed
to ofd_process_xml_file().

The hash that, taken together, comprises arguments 3 through N, can have
the following key/value pairs:

 SECTION : Reference to a list of section names.  All <section>'s are 
   removed except those named here.  If this argument is not supplied,
   no sections are removed.
 DIE_TAG : Reference to a list of Dwarf tag names.  All DIE'S, except
   those with the given tag names, are removed.  If this argument is not
   supplied, no DIE's are removed.

If a proposed part of XML to remove is found to nest another similar
part, it is not removed.  For example, DIE's that nest other DIE's are not
removed, no matter what the tag name is.

=head2 ofd_strip_xml

 Input: - Name of the XML file, or undef if passing a string
        - Reference to a string
        - A hash of arguments described below

 Returns: Nothing directly.  String is returned via ref (2nd argument).

Similar to ofd_filter_xml, except you specify what should be stripped away.
And you can pass an additional argument: GENERAL.

The hash that, taken together, comprises arguments 3 through N, can have
the following key/value pairs:

 GENERAL : Reference to a list of XML tags.  Everything enclosed by one
   of these XML tags is removed.
 SECTION : Reference to a list of section names.  Every <section> with
   one of these names is removed.
 DIE_TAG : Reference to a list of Dwarf tag names.  Every DIE with one
   of these tag names is removed.

If a proposed part of XML to remove is found to nest another similar
part, it is not removed.  For example, DIE's that nest other DIE's are not
removed, even it matches the name of a tag you supply.  

Calling this function is tricky.  It is easy to make a mistake.  You need
detailed knowledge of both the OFD XML and the information the script
is using from the XML.  Your best bet is to find an example script that uses
it and understand what it is doing.  

=head2 ofd_filter_and_parse_xml

 Input: - Name of the XML file, or '-' for stdin
        - A hash of arguments described below

 Returns: Reference to data structure representing the XML

This function does (conceptually) the same thing as ...

    ofd_filter_xml(...);
    ofd_strip_xml(...);
    $xml_data = ofd_process_xml_file(...);

For a very large (> 10 MB) XML file, using this function instead takes much
less memory.  By thus avoiding or reducing memory thrashing, it can run much
faster.  

The hash passed after the filename is composed of ...

 FILTER => reference to a hash of arguments passed to ofd_filter_xml
 STRIP  => reference to a hash of arguments passed to ofd_strip_xml
 XML_PEEK => reference to a function that expects a reference to the
   $all_lines scalar (from the XML file).  This function usually saves off
   bits of information about the XML.

A typical call looks like ...

   $xml_data = 
      ofd_filter_and_parse_xml(
	 $xml_file,
         FILTER => { SECTION => [qw(.debug_info)],
		     DIE_TAG => [qw(DW_TAG_TI_branch
		                    DW_TAG_compile_unit
		                    DW_TAG_TI_reserved_3
		                    DW_TAG_subprogram)] },
         STRIP => { GENERAL => [qw(string_table
		                   raw_data
				   line_numbers)] },
	 XML_PEEK => \&xml_peek);

=head2 ofd_has_dwarf 

 Input: An element from an array returned by ofd_each_file

 Returns: True if XML data has Dwarf information, false otherwise

=head2 ofd_find_debug_info

 Input: An element from an array returned by ofd_each_file

 Returns: Reference to the .debug_info section from the Dwarf information.
   Returns undef if it is not found or is poorly formed.

=head2 ofd_find_compile_unit_die

  Input: A reference to a single element of the "compile_unit" array at
    the top level of the Dwarf data structure.

  Returns: A reference to the DIE contained within the compile unit that
    has the tag DW_TAG_compile_unit

A "compile unit" is really just a fancy name for a file.  A compile unit
data structure almost always looks like ...

           'compile_unit' => [         # list of files
           {
             'die' => [                # list of top level DIE's
             {
               'tag' => 'DW_TAG_compile_unit'
               ...

It is possible there are no DIE's, or when there is more than one, the
DW_TAG_compile unit DIE is not the first one.  This routine sorts through
all that to return the DW_TAG_compile_unit DIE, or undef if not found.

=head2 ofd_find_all_dies

 Input: - A reference to the first DIE to search
        - A reference to a hash for saving off all the DIE's, indexed by
	  DIE id.  Pass undef if not desired.
        - The remaining argument are a hash described below.

Use this function to organize DIE's into hashes separated by tag name,
and indexed by DIE id.

The arguments 3 through N comprise a hash where keys are Dwarf tags and
values are references to a hash, keyed by id, that saves off DIE's with
the matching tag.  There is no limit on the length of this hash.  Search
for as many tags as you want.

Arguments 2 through N can be undef (though it is pointless for all
of them to be undef).  

A typical call looks like ...

	 ofd_find_all_dies($top_level_die, \%dies_by_id,
	                   DW_TAG_TI_branch     => \%branch_dies,
	                   DW_TAG_TI_reserved_3 => \%branch_dies);

=head2 ofd_put_dies_in_array

 Input: - A reference to the first DIE to search
        - The remaining arguments are a hash described below

Use this function to organize DIE's into arrays separated by tag name.

Arguments 2 through N comprise a hash where keys are Dwarf tags and values
are references to an array used to save off the DIE's with the matching
tag.  There is no limit on the length of this hash.  Search for as many
tags as you want.  DIE's are searched and placed into the corresponding
array in the same order as they are found in the XML, which is the same
order as they are placed in the object file. 

=head2 ofd_put_dies_in_hash

 Input: - A reference to the first DIE to search
        - The remaining argument are a hash described below.

Use this function to organize DIE's into hashes separated by tag name,
and indexed by DIE id.

The arguments 2 through N comprise a hash where keys are Dwarf tags and
values are references to a hash, keyed by id, that saves off DIE's with
the matching tag.  There is no limit on the length of this hash.  Search
for as many tags as you want.

=head2 ofd_find_attrs

  Input: - Reference to a DIE whose attributes are searched
         - The remaining arguments are a hash described below

Use this function to copy the attributes of a DIE to variables.  

Arguments 2 through N comprise a hash where keys are Dwarf attributes 
and values are references to variables which are assigned the value of
the attribute.  There is no limit to the length of this hash.  Search for
as many attributes as you want.

A typical call looks like ...

        ofd_find_attrs($func_die,
	               DW_AT_TI_symbol_name => \$func_name,
	               DW_AT_low_pc         => \$start_addr,
	  	       DW_AT_high_pc        => \$end_addr);

Tip on recommended use: Set all the scalars to undef just before calling,
then insure that subsequent code can handle any one scalar remaining undef.

=head2 ofd_cg_xml_version

If the command line option --cg_xml_version is present, print out, on stderr,
the version of the cg_xml package in use.  Must be called BEFORE the main
script does any command line processing.

=head1 VERSION CHECKING

You can have Perl automatically check you are using the correct version
of XML_TI_OFD.pm by writing something similar to ...

   use XML_TI_OFD 2.11;

So you know what version to check for, here is a quick summary of what
version introduced which functions or changes ...

=head2 Version 2.00

Introduce the functions:

 - ofd_process_xml_file
 - ofd_find_lib_name
 - ofd_get_input_file_name
 - ofd_each_file
 - ofd_each_section
 - ofd_each_symbol
 - ofd_each_die_entry

=head2 Version 2.10

Introduces the function:

 - ofd_strip_xml

=head2 Version 2.11

Introduces the functions:

 - ofd_filter_xml
 - ofd_has_dwarf
 - ofd_find_debug_info
 - ofd_find_compile_unit_die
 - ofd_find_all_dies
 - ofd_find_attrs

Also, can pass string to ofd_strip_xml by passing undef for the file arg

=head2 Version 2.20

Introduces the functions:

 - ofd_filter_and_parse_xml
 - ofd_put_dies_in_array
 - ofd_put_dies_in_hash

=head2 Version 3.10

Introduces support for ELF files.

=head2 Version 3.11

Introduces the function: ofd_cg_xml_version
   
=head1 DEBUG FEATURES

Access to this variable and function are strictly limited to the fully
qualified XML_TI_OFD:: syntax.  These names are too widely used to be
handled any other way.

=head2 $XML_TI_OFD::debug

Whether to dump the Perl data structures to stdout.  Set to undef by default.

=head2 XML_TI_OFD::dump_out

Input: Reference to all or part of the Perl data structure corresponding
to the XML file.

Returns: Nothing

Dumps the Perl data structure to STDOUT.  Helpful for understanding how to 
traverse the data structure, or diagnose bugs.

=cut

#=============================================================================
# Code starts here ...
#=============================================================================
# Module Level Details ...
#
# The vast majority of users of this module do not need to know any more than
# what is written above.  The module is well commented for maintenance
# purposes, *not* to make users think they are required to completely
# understand this code before they can rely on it.  Modification of this code
# requires a moderately advanced knowledge of Perl, XML::Simple, and the
# structure of the OFD XML files.
#
# Note the XML tag that corresponds to a library is <archive>.  The rest of
# the comments will use the terms "archive" and "library" interchangeably.
#=============================================================================

package XML_TI_OFD;
require Exporter;

# Never use commas inside qw()!

our @ISA       = qw(Exporter);

#=============================================================================
# Export commonly used functions by default.  All of these functions are
#    prefixed with the name "ofd_".  
#=============================================================================
our @EXPORT    = qw(ofd_filter_and_parse_xml
                    ofd_process_xml_file
		    ofd_find_lib_name
		    ofd_get_input_file_name
		    ofd_each_file
                    ofd_is_executable
                    ofd_machine_name
                    ofd_entry_point
		    ofd_each_section
                    ofd_sect_name
                    ofd_sect_size
                    ofd_sect_run_addr
                    ofd_sect_load_addr
                    ofd_sect_is_code
                    ofd_sect_is_data
                    ofd_sect_is_init
                    ofd_sect_is_uninit
                    ofd_sect_is_write
                    ofd_sect_raw_data
                    ofd_sect_raw_data_ptr
		    ofd_each_symbol
                    ofd_sym_is_global
                    ofd_sym_name
                    ofd_sym_value
		    ofd_sym_sect_name
                    ofd_each_die_entry
		    ofd_filter_xml
		    ofd_strip_xml
                    ofd_has_dwarf
                    ofd_find_debug_info
		    ofd_each_debug_info
                    ofd_find_compile_unit_die
                    ofd_find_all_dies
		    ofd_put_dies_in_array
		    ofd_put_dies_in_hash
                    ofd_find_attrs
		    ofd_cg_xml_version);

#=============================================================================
# Export legacy and seldom used functions by explicit request
#=============================================================================
our @EXPORT_OK = qw(process_xml_file); 

#=============================================================================
# Can force use of particular version of this module with syntax like ...
#    use XML_TI_OFD 2.10;
# Version 2.00 introduces several new functions for traversing the Perl
# data structure built by ofd_process_xml_file.   See the VERSION CHECKING
# section of the POD above for what features were introduced in what version.
#=============================================================================
our $VERSION   = '3.11';

use strict;
use warnings;

#=============================================================================
# Bring in the XML parsing module.  The update to XML::Simple version 2.22
# exposed a bug in how KeyAttr is configured.
#
# OLD: KeyAttr => undef
# NEW: KeyAttr => []
#
# The change may or may not work with older XML::Simple modules, so make sure
# it is at least 2.22.
#=============================================================================
use XML::Simple 2.22 qw(:strict);

#=============================================================================
# Module for handling command line options
#=============================================================================
use Getopt::Long;

#=============================================================================
# Global variables not explicitly exposed outside the module
#=============================================================================
our $debug  = undef;
our $is_elf = undef;

#==============================================================================
# OFD_FILTER_XML - Filter out all sections and DIE tags except the listed ones.
# DIE's that nest other DIE's are *not* deleted, no matter what the tag is.
#------------------------------------------------------------------------------
# It is interesting to note this is possible ...
#
#      <die> outer
#          <die> inner
#          ...
#          </die>
#      </die>
#
# becomes 
#
#      <die> outer
#          ...
#      </die>             
#
# And if you just ran this one more time, you would get rid of that outer DIE.
# Not going to pursue this here ...
#==============================================================================
sub ofd_filter_xml
{
   my ($filename, $ref_all_lines, %filter_args) = @_;
   my(%seen, @tags_to_delete, @sects_to_delete, %what_to_delete);

   #--------------------------------------------------------------------------
   # Read all the lines of the XML file into the string ref
   #--------------------------------------------------------------------------
   read_all_lines($filename, $ref_all_lines);

   #--------------------------------------------------------------------------
   # Find all the tags which are present in the XML, remove the ones you
   # want to keep.  The rest will be be deleted.
   #--------------------------------------------------------------------------
   if (exists $filter_args{DIE_TAG})
   {
      while ($$ref_all_lines =~ m/\b(DW_TAG_\w+)/g)
	 { $seen{$1} = 1; }
      foreach (@{$filter_args{DIE_TAG}}) { delete $seen{$_}; }
      @tags_to_delete = keys %seen;
      $what_to_delete{DIE_TAG} = \@tags_to_delete;
   }

   #--------------------------------------------------------------------------
   # Same thing as with tags, but with sections instead
   #--------------------------------------------------------------------------
   if (exists $filter_args{SECTION})
   {
      while ($$ref_all_lines =~ m/<section>\s*<name>([^<]+)</g)
	 { $seen{$1} = 1; }
      foreach (@{$filter_args{SECTION}}) { delete $seen{$_}; }
      @sects_to_delete = keys %seen;
      $what_to_delete{SECTION} = \@sects_to_delete;
   }

   #--------------------------------------------------------------------------
   # Delete 'em!
   #--------------------------------------------------------------------------
   ofd_strip_xml(undef, $ref_all_lines, %what_to_delete);
}
 
#==============================================================================
# OFD_STRIP_XML
#==============================================================================
sub ofd_strip_xml 
{
   my ($filename, $ref_all_lines, %strip_args) = @_;
   my ($delete, $xml_tag, $sect_name, $die_name);

   #--------------------------------------------------------------------------
   # Read all the lines of the XML file into the string ref
   #--------------------------------------------------------------------------
   read_all_lines($filename, $ref_all_lines);

   #--------------------------------------------------------------------------
   # Remove all of a given tag and everything under it.  If nesting occurs,
   # nothing gets removed.
   #--------------------------------------------------------------------------
   foreach $xml_tag (@{$strip_args{GENERAL}})
   {
      #-----------------------------------------------------------------------
      # Escape all non-word non-whitespace chars in the xml tag name
      #-----------------------------------------------------------------------
      $xml_tag =~ s/([^\w\s])/\\$1/g;

      #-----------------------------------------------------------------------
      # Construct the pattern for deletion, and then delete it.
      #-----------------------------------------------------------------------
      $delete =
         delete_pattern("<$xml_tag>",                      # starts with
	                 "<$xml_tag>",                     # may not nest this
			 "</$xml_tag>");                   # ends with
      $$ref_all_lines =~ s/$delete//g;
   }

   #--------------------------------------------------------------------------
   # Remove all sections with the given names.
   #--------------------------------------------------------------------------
   foreach $sect_name (@{$strip_args{SECTION}})
   {
      #-----------------------------------------------------------------------
      # Escape all non-word non-whitespace chars in sect_name.  '.debug_line' 
      # becomes '\.debug_line'.
      #-----------------------------------------------------------------------
      $sect_name =~ s/([^\w\s])/\\$1/g;

      #-----------------------------------------------------------------------
      # Construct the pattern for deletion, and then delete it.
      #-----------------------------------------------------------------------
      $delete =
         delete_pattern(
	    '<section>\s*<name>' . $sect_name . '</name>', # starts with
	    '<section>',                                   # may not nest this
	    '</section>');                                 # ends with
      $$ref_all_lines =~ s/$delete//g;
   }

   #--------------------------------------------------------------------------
   # Remove all DIE's with a given tag name.  If any of those DIE's are
   # found to nest another DIE, it is not removed.
   #--------------------------------------------------------------------------
   foreach $die_name (@{$strip_args{DIE_TAG}})
   {
      #-----------------------------------------------------------------------
      # Escape all non-word non-whitespace chars in die_name
      #-----------------------------------------------------------------------
      $die_name =~ s/([^\w\s])/\\$1/g;

      #-----------------------------------------------------------------------
      # Construct the pattern for deletion, and then delete it.  Note
      # '<die[^>]+>' means match '<die' followed by 1 or more characters that
      # are not a '>', followed by a '>'.  This skips over 'id = val' chars.
      #-----------------------------------------------------------------------
      $delete =
         delete_pattern(
	    '<die[^>]+>\s*<tag>' . $die_name . '</tag>',  # starts with
	    '<die[^>]+>',                                 # may not nest this
	    '</die>');                                    # ends with
      $$ref_all_lines =~ s/$delete//g;
   }

   #--------------------------------------------------------------------------
   # Remove most unneeded whitespace.  This removes all whitespace before
   # and after any newline.  Thus blank lines are deleted.  Running this
   # last removes any blank lines created by the above deletions.
   #--------------------------------------------------------------------------
   $$ref_all_lines =~ s/[ \t]*\n\s*/\n/g;
}

#=============================================================================
# OFD_FILTER_AND_PARSE_XML - Documented in the POD above.  The key to
#    saving memory is insuring that the $all_lines scalar that holds the
#    XML is not in memory at the same time as the XML data structure.  
#=============================================================================
sub ofd_filter_and_parse_xml
{
   my ($file_name, %args) = @_;
   my ($temp_fh, $all_lines, $ten_mb);

   $all_lines = undef;

   if ($args{FILTER})
   {
      ofd_filter_xml($file_name,
	             \$all_lines,
		     %{$args{FILTER}});
   }

   if ($args{STRIP})
   {
      ofd_strip_xml(($all_lines) ? undef : $file_name, 
	            \$all_lines,
		    %{$args{STRIP}});
   }

   if ($args{XML_PEEK})
   {
      if (!$all_lines)
	 { read_all_lines($file_name, \$all_lines); }

      $args{XML_PEEK}(\$all_lines);
   }

   if (!$all_lines)
   {
      return ofd_process_xml_file($file_name);
   }

   #--------------------------------------------------------------------------
   # If the size of the XML is over 10 megabytes, then copy it out to a
   # temporary file for parsing.  Otherwise, have the parser read from the
   # huge scalar.  The temp file method avoids having the huge scalar and the
   # XML data structure all in memory at the same time.  The 10 MB choice is
   # pretty arbitrary.  So long as taking up all that memory doesn't cause the
   # machine to thrash, each method runs in about the same time.  But, when
   # using a temp file either avoids or reduces the thrashing, it is much
   # faster.
   #--------------------------------------------------------------------------
   $ten_mb = 10 * (1 << 20);
   if (length($all_lines) > $ten_mb)
   {
      #-----------------------------------------------------------------------
      # Copy the huge scalar out to a temporary file
      #-----------------------------------------------------------------------
      open ($temp_fh, "+>", undef) or die "Cannot create temp file: $!";
      print $temp_fh "$all_lines";
      seek $temp_fh, 0, 0;

      #-----------------------------------------------------------------------
      # Free the memory used for the huge scalar
      #-----------------------------------------------------------------------
      $all_lines = undef;

      #-----------------------------------------------------------------------
      # Convert XML to Perl data structures
      #-----------------------------------------------------------------------
      return ofd_process_xml_file($temp_fh);
   }
   else
   {
      return ofd_process_xml_file($all_lines);
   }
}

#==============================================================================
# READ_ALL_LINES - Slurp all the lines of the XML file into one big string
#==============================================================================
sub read_all_lines
{
   my ($filename, $ref_all_lines) = @_; 

   #--------------------------------------------------------------------------
   # If no file name, then input is already passed in $ref_all_lines
   #--------------------------------------------------------------------------
   return if (!$filename);

   #--------------------------------------------------------------------------
   # Enable slurp mode 
   #--------------------------------------------------------------------------
   local $/;
   
   #--------------------------------------------------------------------------
   # Process STDIN
   #--------------------------------------------------------------------------
   if ($filename eq '-')
   {
      $$ref_all_lines = <STDIN>;
   }
   #--------------------------------------------------------------------------
   # Process regular file
   #--------------------------------------------------------------------------
   else
   {
      open(FH, "<$filename") or die "Cannot open $filename: $!";
      $$ref_all_lines = <FH>;
      close(FH);
   }
}

#==============================================================================
# DELETE_PATTERN - Returns a regular expression pattern for parts of the
#   XML that will be deleted.
#==============================================================================
sub delete_pattern
{
   #--------------------------------------------------------------------------
   # $start   : the beginning of the pattern
   # $no_nest : If this appears anywhere after the start, it indicates nesting
   #            is occurring.  Nothing gets deleted when this happens.
   # $end     : the end of the pattern
   #--------------------------------------------------------------------------
   my ($start, $no_nest, $end) = @_;

   #--------------------------------------------------------------------------
   # This regex is modeled on one found on pg. 223 of Perl Cookbook 2nd Ed.
   # Reading all of recipe 6.18 is useful in understanding the magic here.
   # The expression matches a minimal length part of the string that starts
   # and ends as indicated and $no_nest never appears in the middle.
   #--------------------------------------------------------------------------
   return
      qr{  $start           # start of the pattern
	   (?:              # group without capture
	      (?!           #    peek ahead from here, negative version ...
	         $no_nest   #    this string cannot start at this location
	      )             #    done peeking ahead
	      .             #    any character including \n - due to /s
	   )*?              # repeat 0 or more times - non-greedy version
	   $end             # end the pattern
        }sx;                # s means . matches \n
}

#=============================================================================
# OFD_PROCESS_XML_FILE - Main entry point to the module
#=============================================================================
sub ofd_process_xml_file
{
   my (%args) = @_[1..$#_];   # copies all args except the 0th one
   return process_xml_file(@_);
}

#=============================================================================
# PROCESS_XML_FILE - The original main entry point to the module.  Kept for
#    legacy purposes.  
#=============================================================================
sub process_xml_file
{
   #--------------------------------------------------------------------------
   # No longer copy argument from @_ array.  That argument can be a very
   # long string holding the entire XML file.  Thus, copying it can be
   # expensive.  Instead, take advantage of Perl's convention for passing
   # a reference to the argument in @_[0].  Makes the code a bit harder to
   # read, but much more efficient in the long string case.  This technique
   # is also used in parse_xml_file.
   #--------------------------------------------------------------------------
   #my($filename) = @_;  # Can be filename or string, but not a file handle
   my($xml_data, $file_data);

   #--------------------------------------------------------------------------
   # XML::Simple itself does not directly parse XML.  Instead, it relies on
   # yet other Perl modules.  Experimentation has shown that XML::Parser is
   # much faster than other modules.   So, test to see if XML::Parser is
   # available.  If it is, make sure it gets used.  Use 'perldoc XML::Simple'
   # to get more info on the PREFERRED_PARSER setting.
   #--------------------------------------------------------------------------
   eval { require XML::Parser; };
   if (!$@) { $XML::Simple::PREFERRED_PARSER = 'XML::Parser'; }

   $xml_data = parse_xml_file($_[0]);
   $xml_data = fixup($xml_data);

   $file_data = (ofd_each_file($xml_data))[0];
   $is_elf    = exists $file_data->{elf};

   dump_out($xml_data) if ($debug);

   return $xml_data;
}

#=============================================================================
# PARSE_XML_FILE - Parse the XML file using the Perl module XML::Simple.  
#=============================================================================
sub parse_xml_file
{
   #--------------------------------------------------------------------------
   # See comment in process_xml_file about this change
   #--------------------------------------------------------------------------
   #my($input) = @_;
   my($xml_data);

   $xml_data = XMLin($_[0],
	       #--------------------------------------------------------------
	       # Thought about using this to make the symbol table a hash
	       # keyed on the symbol name.  Can't.  There are cases where
	       # multiple symbols can legitimately have the same name.
	       # In stabs debug format the symbol table becomes a complicated
	       # thing where interpreting what a symbol is depends on where
	       # it is in the table relative to other symbols, and so on.
	       # Local symbols with the same name from different functions 
	       # will appear at the same level in the symbol table.  They
	       # are disambiguated by other surrounding symbols that indicate
	       # they are from different functions.
	       #--------------------------------------------------------------
	       KeyAttr => [],

	       #--------------------------------------------------------------
	       # The first group of tags appears in COFF files.  The 2nd
	       # group of tags appears in ELF files.
	       #--------------------------------------------------------------
	       ForceArray => [
		  qw(
		     object_file
		     attribute
		     symbol
		     die
		     line_entry
		     row      
		     reloc_entry
		     function
		     line_entry
		     compile_unit

		     elf32_phdr
		     elf32_sym
		     attribute
		     vendor_section
		     elf32_reloc
		     elf32_dyn
		     elf32_verdef
		     elf32_verdaux
		     elf32_verneed
		     elf32_vernaux
		     )

		     #-------------------------------------------------------
		     # Wanted to add these but couldn't ...
		     # - 'string' messes up attributes in die records
		     # - 'section' messes up symbol records (for COFF and ELF)
		     # - 'flag' (for ELF) messes up Dwarf attributes
		     # This is addressed in the "fixup" routines below.
		     #-------------------------------------------------------
		    ],
	      
	       GroupTags => {
		  #----------------------------------------------------------
		  # The following occur in COFF files
		  #----------------------------------------------------------
		  relocations    => 'reloc_entry',
		  symbol_table   => 'symbol',
		  table          => 'row',
		  #----------------------------------------------------------
		  # The following occur in ELF files
		  #----------------------------------------------------------
		  program_table  => 'elf32_phdr',
		  section_table  => 'section',
		  p_flags        => 'flag',
		  e_flags        => 'flag',
		  sh_flags       => 'flag',
		  ti_flags       => 'flag',
		  flags          => 'flag',
		  vd_flags       => 'flag',
		  vna_flags      => 'flag',
		  attribute_list => 'attribute',
		  members        => 'section',
		  dynamic_table  => 'elf32_dyn',
		  verdef_table   => 'elf32_verdef',
		  verneed_table  => 'elf32_verneed',

		  #----------------------------------------------------------
		  # Would like to do this one as well, but symbol_table
		  # is already a key in this hash.  This is handled later
		  # on in fixup_file below.
		  #----------------------------------------------------------
		  #symbol_table  => 'elf32_sym', 

		  #----------------------------------------------------------
		  # Would like to do this one, but can't.  Already have
		  # a relocations entry for COFF.  And a hash like this
		  # can have only one key per entry.
		  #----------------------------------------------------------
		  #relocations   => 'elf32_reloc',

		  #----------------------------------------------------------
		  # Not doing ...
		  #    string_table => 'string'
		  # for ELF, even though it is a good candidate.  The
		  # string table is never used in the cg_xml scripts.  So
		  # why mess with it at all?
		  #----------------------------------------------------------
	       },

	       ValueAttr => [ qw(idref) ],

	       SuppressEmpty => undef
	       );

   return $xml_data;
}

#=============================================================================
# FIXUP - Fix some of the odd things that XML::Simple does
#=============================================================================
sub fixup
{
   my($xml_data) = @_;
   my($file);

   #--------------------------------------------------------------------------
   # XML::Simple is configured to always return an array for the tag
   # 'object_file' even if there is only 1 object file.  When it is a library,
   # that makes sense.  When it is a single object file, fix it to be a
   # single record.
   #--------------------------------------------------------------------------
   if (   !exists($xml_data->{'archive'})
       && exists($xml_data->{'object_file'}))
   {
      $xml_data->{'object_file'} = $xml_data->{'object_file'}->[0];
   }

   #--------------------------------------------------------------------------
   # Fixup things that live inside file level
   #--------------------------------------------------------------------------
   foreach $file (ofd_each_file($xml_data))
      { fixup_file($file); }

   return $xml_data;
}

#=============================================================================
# FIXUP_FILE - Helper to fixup.  Works on one file's worth of XML data.
#=============================================================================
sub fixup_file
{
   my($file) = @_;
   my($tag, $record, $prog_hdr, $sect, $group, $entry, $inner);

   #--------------------------------------------------------------------------
   # Insure that the 'section' which appears under both 'dwarf' and 'ti_coff'
   # is an array, even if it contains only 1 section.  Note XML::Simple
   # cannot be allowed to do this with the ForceArray feature.  That would
   # foul up the 'section' entries which occur in each symbol table record.
   #--------------------------------------------------------------------------
   foreach $tag (qw(dwarf ti_coff))
   {
      next unless (   exists $file->{$tag}
	           && exists $file->{$tag}->{section});
      $record = $file->{$tag}->{section};
      if ($record && ref($record) ne 'ARRAY')
         { $file->{$tag}->{section} = [ $record ]; }
   }

   #--------------------------------------------------------------------------
   # Insure that the 'string' part of the string table is an array, even if
   # it contains only 1 string.  Similar to 'section' cannot allow XML::Simple
   # to do it.  That would foul up the 'string' attribute which occurs in
   # many dwarf 'die' records.
   #--------------------------------------------------------------------------
   if (   exists $file->{ti_coff}
       && exists $file->{ti_coff}->{string_table}
       && exists $file->{ti_coff}->{string_table}->{string})
   {
      $record = $file->{ti_coff}->{string_table}->{string};
      if ($record && ref($record) ne 'ARRAY')
         { $file->{ti_coff}->{string_table}->{string} = [ $record ]; }
   }

   #--------------------------------------------------------------------------
   # Handle file header flags
   #--------------------------------------------------------------------------
   if (   exists  $file->{elf}
       && exists  $file->{elf}->{elf32_ehdr})
      { build_flag_hash($file->{elf}->{elf32_ehdr}, 'e_flags'); }

   #--------------------------------------------------------------------------
   # Handle segment flags
   #--------------------------------------------------------------------------
   if (   exists $file->{elf}
       && exists $file->{elf}->{program_table})
   {
      foreach $prog_hdr (@{$file->{elf}->{program_table}})
         { build_flag_hash($prog_hdr, 'p_flags'); }
   }

   #--------------------------------------------------------------------------
   # Insure the section_table is an array.  Can't do that in XML::Simple.
   # See comments where XMLin is called.
   #--------------------------------------------------------------------------
   if (   exists $file->{elf}
       && exists $file->{elf}->{section_table}
       && ref($file->{elf}->{section_table}) ne 'ARRAY')
   {
      $record = $file->{elf}->{section_table};
      $file->{elf}->{section_table} = [ $record ];
   }

   #--------------------------------------------------------------------------
   # Walk through the ELF sections, if any
   #--------------------------------------------------------------------------
   if (   exists $file->{elf}
       && exists $file->{elf}->{section_table})
   {
      foreach $sect (@{$file->{elf}->{section_table}})
      {
         #--------------------------------------------------------------------
	 # Handle section header flags
         #--------------------------------------------------------------------
	 if (exists $sect->{elf32_shdr})
	 { 
	    build_flag_hash($sect->{elf32_shdr}, 'sh_flags');
            #-----------------------------------------------------------------
	    # All ELF object files have that completely empty section as
	    # the first section.  Much code becomes easier to write if it
	    # does not have to worry that the name string might be undef.
            #-----------------------------------------------------------------
	    if (!defined($sect->{elf32_shdr}->{sh_name_string}))
	       { $sect->{elf32_shdr}->{sh_name_string} = ""; }
	 }

         #--------------------------------------------------------------------
	 # Handle TI specific section flags
         #--------------------------------------------------------------------
         build_flag_hash($sect, 'ti_flags');

         #--------------------------------------------------------------------
	 # Handle group flags
         #--------------------------------------------------------------------
	 if (exists $sect->{group})
	    { build_flag_hash($sect->{group}, 'flags'); }

         #--------------------------------------------------------------------
         #--------------------------------------------------------------------
	 if (   exists $sect->{group}
	     && exists $sect->{group}->{members}
	     && ref($sect->{group}->{members}) ne 'ARRAY')
	 {
	    $record = $sect->{group}->{members};
	    $sect->{group}->{members} = [ $record ];
	 }

         #--------------------------------------------------------------------
	 # Handle verdef table flags
         #--------------------------------------------------------------------
         if (exists $sect->{verdef_table})
	 {
	    foreach $entry (@{$sect->{verdef_table}})
	       { build_flag_hash($entry, 'vd_flags'); }
	 }

         #--------------------------------------------------------------------
	 # Handle verneed table flags
         #--------------------------------------------------------------------
         if (exists $sect->{verneed_table})
	 {
	    foreach $entry (@{$sect->{verneed_table}})
	    {
	       next if (!exists($entry->{elf32_vernaux}));
	       foreach $inner (@{$entry->{elf32_vernaux}})
	          { build_flag_hash($inner, 'vna_flags'); }
	    }
	 }

	 #--------------------------------------------------------------------
	 # Do the GroupTags thing on the symbol_table/elf32_sym tag
	 # combination.  Cannot let XML::Simple do it because it is already
	 # grouping symbol_table/symbol for COFF.
	 #--------------------------------------------------------------------
	 if (   exists $sect->{symbol_table}
	     && exists $sect->{symbol_table}->{elf32_sym})
         {
	    $sect->{symbol_table} = $sect->{symbol_table}->{elf32_sym};
	 }
      }
   }
}

#=============================================================================
# BUILD_FLAG_HASH
#--------------------------------------------------------------------------
# Cannot allow XML::Simple to make an array out of the 'flag' entries that
# appear under places like sh_flags.  That messes up the 'flag' field that
# appears in Dwarf entries.  Thus e_flags, sh_flags, etc. can reference either
# a string or an array or undef.  Since this has to be fixed anyway, go ahead
# and take the trouble to make it a hash keyed on the flag.  That way, it is
# easy to check for the existence of a flag with a hash lookup, rather
# than a loop through an array.
#=============================================================================
sub build_flag_hash
{
   my ($ref, $flag_name) = @_;
   my ($record, $flag, %flag_hash);

   if (defined $ref->{$flag_name})
   {
      $record = $ref->{$flag_name};
      if (ref($record) ne 'ARRAY')
      {
	 $ref->{$flag_name} = { "$record" => 1 };
      }
      else
      {
	 %flag_hash = ();
	 foreach $flag (@$record) { $flag_hash{$flag} = 1; }
	 $ref->{$flag_name} = { %flag_hash };
      }
   }
   #--------------------------------------------------------------------------
   # If it is undef, change it to reference an empty hash.  That way, a
   # test like "if (exists $sect->{elf32_shdr}->{sh_flags}->{SHF_ALLOC})"
   # does not cause the "sh_flags" reference to change from undef to, through
   # auto-vivification, pointing to an empty hash.  This makes sure it
   # consistently refers to an empty hash.
   #--------------------------------------------------------------------------
   else
   {
      $ref->{$flag_name} = {};
   }
}

#=============================================================================
# OFD_FIND_LIB_NAME - The main way to check if input file is a library or not.
#    Input is a reference to a Perl data structure built by process_xml_file.
#    If it is a library, return the library name.  Otherwise, return undef.  
#=============================================================================
sub ofd_find_lib_name
{
   my ($xml_data) = @_;

   if (exists $xml_data->{'archive'})
   {
      return $xml_data->{'archive'}->{'name'};
   }
   else
   {
      return undef;
   }
}

#=============================================================================
# OFD_GET_INPUT_FILE_NAME - Returns the name of the input file from which the
#    XML is created.  If it is a library, return the name of the library.  If
#    it is an .obj/.out file, return the name of that file.
#=============================================================================
sub ofd_get_input_file_name
{
   my ($xml_data) = @_;
   my ($file_name);

   $file_name = ofd_find_lib_name($xml_data);
   if (!$file_name)
   {
      $file_name = (ofd_each_file($xml_data))[0]->{'name'};
   }

   return $file_name;
}

#=============================================================================
# OFD_EACH_FILE - For iterating through each object file.  Details in the POD.
#=============================================================================
sub ofd_each_file
{
   my ($xml_data) = @_;

   #--------------------------------------------------------------------------
   # This is a library ...
   #--------------------------------------------------------------------------
   if (exists $xml_data->{'archive'})
   {
      return @{$xml_data->{'archive'}->{'object_file'}};
   }
   #--------------------------------------------------------------------------
   # Not a library ...
   #--------------------------------------------------------------------------
   else
   {
      return $xml_data->{'object_file'};
   }
}

#=============================================================================
# OFD_IS_EXECUTABLE
#=============================================================================
sub ofd_is_executable
{
   my ($xml_data) = @_;
   my (@file_list, $file_data, $file_hdr);

   @file_list = ofd_each_file($xml_data);
   $file_data = $file_list[0];

   if (!$is_elf)
   {
      $file_hdr = $file_data->{ti_coff}->{file_header};
      return (exists($file_hdr->{exec}) && $file_hdr->{exec} eq 'true');
   }
   else
   {
      return ($file_data->{elf}->{elf32_ehdr}->{e_type} eq 'ET_EXEC');
   }
}

#=============================================================================
# OFD_MACHINE_NAME
#=============================================================================
sub ofd_machine_name
{
   my ($xml_data) = @_;
   my (@file_list, $file_data, %coff_id_to_name, %elf_machine_to_name, 
       $targ_num, $targ_name);

   %coff_id_to_name = (
      0x92 => 'C2400',
      0x97 => 'ARM',
      0x98 => 'C5400',
      0x99 => 'C6000',
      0x9c => 'C5500',
      0x9d => 'C2000',
      0xa0 => 'MSP430',
      0xa1 => 'C5500+',
   );

   %elf_machine_to_name = (
      EM_ARM      => 'ARM',
      EM_TI_C6000 => 'C6000',
      EM_TI_C2000 => 'C2000',
      EM_TI_C5500 => 'C5500',
      EM_TI_ARP32 => 'ARP32',
      EM_MSP430   => 'MSP430',
      EM_TI_PRU   => 'PRU',
   );

   @file_list = ofd_each_file($xml_data);
   $file_data = $file_list[0];

   if (!$is_elf)
   {
      $targ_num =
         str_to_num($file_data->{ti_coff}->{file_header}->{target_id});
      $targ_name = $coff_id_to_name{$targ_num};
   }
   else
   {
      $targ_name = 
         $elf_machine_to_name{$file_data->{elf}->{elf32_ehdr}->{e_machine}};
   }

   return $targ_name if ($targ_name);
   return 'unknown';
}

#=============================================================================
# OFD_ENTRY_POINT
#=============================================================================
sub ofd_entry_point
{
   my ($file_data) = @_;

   if (   !$is_elf
       && exists $file_data->{ti_coff}->{optional_file_header}->{entry_point})
   {
      return str_to_num($file_data->{ti_coff}->{optional_file_header}->
	                                                     {entry_point});
   }

   if (   $is_elf
       && exists $file_data->{elf}->{elf32_ehdr}->{e_entry})
   {
      return str_to_num($file_data->{elf}->{elf32_ehdr}->{e_entry});
   }

   return undef;
}

#=============================================================================
# OFD_EACH_SECTION - For iterating through each section.  Details in the POD.
#=============================================================================
sub ofd_each_section
{
   my ($file_data) = @_;

   if (!$is_elf)
      { return @{$file_data->{ti_coff}->{section}}; }
   else
      { return @{$file_data->{elf}->{section_table}}; }
}

#=============================================================================
# OFD_SECT_NAME
#=============================================================================
sub ofd_sect_name
{
   my ($sect) = @_;

   if (!$is_elf)
      { return $sect->{name}; }
   else
      { return $sect->{elf32_shdr}->{sh_name_string}; }
} 

#=============================================================================
# OFD_SECT_SIZE
#=============================================================================
sub ofd_sect_size
{
   my ($sect) = @_;

   if (!$is_elf)
      { return str_to_num($sect->{raw_data_size}); }
   else
      { return str_to_num($sect->{elf32_shdr}->{sh_size}); }
}

#=============================================================================
# OFD_SECT_RUN_ADDR
#=============================================================================
sub ofd_sect_run_addr
{
   my ($sect) = @_;

   if (!$is_elf)
      { return str_to_num($sect->{physical_addr}); }
   else
      { return str_to_num($sect->{elf32_shdr}->{sh_addr}); }
}

#=============================================================================
# OFD_SECT_LOAD_ADDR
#=============================================================================
sub ofd_sect_load_addr
{
   my ($sect, $file_data) = @_;
   my ($size, $sect_run, $sect_file,
       $segment, $seg_run, $seg_load, $seg_sz, $seg_file);

   if (!$is_elf)
      { return str_to_num($sect->{virtual_addr}); }

   if (!$file_data)
   {
      warn 'File data reference required for ofd_sect_load_addr when ' .
           'processing ELF files';
      return undef;
   }

   $size = ofd_sect_size($sect);
   if (!$size || !exists($sect->{elf32_shdr}->{sh_flags}->{SHF_ALLOC}))
   {
      warn 'Load address not computed for sections that are empty or ' .
           'not loaded to the target';
      return undef;
   }

   if (!defined($file_data->{elf}->{program_table}))
   {
      warn 'Load address not computed for file that does not have a ' .
           'segment table';
      return undef;
   }

   $sect_run = ofd_sect_run_addr($sect);
   $sect_file = ofd_sect_raw_data_ptr($sect);
   foreach $segment (@{$file_data->{elf}->{program_table}})
   {
      $seg_run  = str_to_num($segment->{p_vaddr});
      $seg_load = str_to_num($segment->{p_paddr});
      $seg_sz   = str_to_num($segment->{p_memsz});
      $seg_file = str_to_num($segment->{p_offset});

      #-----------------------------------------------------------------------
      # If run address is between start (inclusive) and end (exclusive) of
      # segment memory range, and the section file pointer is between the
      # start (inclusive) and end (exclusive) of the segment file contents
      # are located, then it belongs to this segment.  
      #-----------------------------------------------------------------------
      if (   ($seg_run <= $sect_run)
          && ($sect_run < ($seg_run + $seg_sz))
          && ($seg_file <= $sect_file)
	  && ($sect_file < ($seg_file + $seg_sz)))
         { return $seg_load + ($sect_run - $seg_run); }
   }

   warn 'Load address not computed';
   return undef;
}

#=============================================================================
# NOT_COFF_CONTROL - Not intended to be directly called from outside
#=============================================================================
sub not_coff_control
{
   my ($sect) = @_;

   return !(   exists($sect->{copy})   && $sect->{copy}   eq 'true'
            || exists($sect->{dummy})  && $sect->{dummy}  eq 'true'
            || exists($sect->{noload}) && $sect->{noload} eq 'true');
}

#=============================================================================
# OFD_SECT_IS_CODE
#=============================================================================
sub ofd_sect_is_code
{
   my ($sect) = @_;
   my ($sect_hdr);

   if (!$is_elf)
   {
      return    not_coff_control($sect) 
             && exists($sect->{text}) && $sect->{text} eq 'true';
   }
   else
   {
      $sect_hdr = $sect->{elf32_shdr};
      return    $sect_hdr->{sh_type} eq 'SHT_PROGBITS'
             && exists($sect_hdr->{sh_flags}->{SHF_ALLOC})
             && exists($sect_hdr->{sh_flags}->{SHF_EXECINSTR});
   }
}

#=============================================================================
# OFD_SECT_IS_DATA
#=============================================================================
sub ofd_sect_is_data
{
   my ($sect) = @_;
   my ($sect_hdr);

   if (!$is_elf)
   {
      return    not_coff_control($sect)
             && (   exists($sect->{data})    && $sect->{data}    eq 'true'
                 || exists($sect->{bss})     && $sect->{bss}     eq 'true'
                 || exists($sect->{regular}) && $sect->{regular} eq 'true');
   }
   else
   {
      $sect_hdr = $sect->{elf32_shdr};
      return    (   $sect_hdr->{sh_type} eq 'SHT_PROGBITS'
                 || $sect_hdr->{sh_type} eq 'SHT_NOBITS')
             &&  exists($sect_hdr->{sh_flags}->{SHF_ALLOC})
             && !exists($sect_hdr->{sh_flags}->{SHF_EXECINSTR});
   }
}

#=============================================================================
# OFD_SECT_IS_INIT
#=============================================================================
sub ofd_sect_is_init
{
   my ($sect) = @_;
   my ($sect_hdr);

   if (!$is_elf)
   {
      return    not_coff_control($sect)
             && (   exists($sect->{text}) && $sect->{text} eq 'true'
                 || exists($sect->{data}) && $sect->{data} eq 'true'
		 || (   exists($sect->{regular})
		     && $sect->{regular} eq 'true'
		     && exists($sect->{file_offsets})
		     && exists($sect->{file_offsets}->{raw_data_ptr})
		     && str_to_num($sect->{file_offsets}->{raw_data_ptr})));
   }
   else
   {
      $sect_hdr = $sect->{elf32_shdr};
      return    $sect_hdr->{sh_type} eq 'SHT_PROGBITS' 
             && exists($sect_hdr->{sh_flags}->{SHF_ALLOC});
   }
}

#=============================================================================
# OFD_SECT_IS_UNINIT - This is not the reverse of ofd_sect_is_init.  For
#    example ".debug_info" is neither an init or uninit section.  It is a
#    copy section, not loaded to the target, filled with debug information
#    used by CCS.
#=============================================================================
sub ofd_sect_is_uninit
{
   my ($sect) = @_;
   my ($sect_hdr);

   if (!$is_elf)
   {
      return    not_coff_control($sect)
             && exists($sect->{bss}) && $sect->{bss} eq 'true';
   }
   else
   {
      $sect_hdr = $sect->{elf32_shdr};
      return    $sect_hdr->{sh_type} eq 'SHT_NOBITS' 
             && exists($sect_hdr->{sh_flags}->{SHF_ALLOC})
             && exists($sect_hdr->{sh_flags}->{SHF_WRITE});
   }
}

#=============================================================================
# OFD_SECT_IS_WRITE
#=============================================================================
sub ofd_sect_is_write
{
   my ($sect) = @_;
   my ($sect_hdr);

   if (!$is_elf)
   {
      warn "Cannot determine whether a COFF section is writeable";
      return undef;
   }
   else
   {
      $sect_hdr = $sect->{elf32_shdr};
      return    (   $sect_hdr->{sh_type} eq 'SHT_PROGBITS'
                 || $sect_hdr->{sh_type} eq 'SHT_NOBITS')
             && exists($sect_hdr->{sh_flags}->{SHF_ALLOC})
             && exists($sect_hdr->{sh_flags}->{SHF_WRITE});
   }
}

#============================================================================
# OFD_SECT_RAW_DATA
#=============================================================================
sub ofd_sect_raw_data
{
   my ($sect) = @_;

   if (exists($sect->{raw_data}))
      { return \$sect->{raw_data}; }

   return undef;
}

#=============================================================================
# OFD_SECT_RAW_DATA_PTR
#=============================================================================
sub ofd_sect_raw_data_ptr
{
   my ($sect) = @_;
   my ($sect_hdr);

   if (!$is_elf)
   {
      if (   exists($sect->{file_offsets})
          && exists($sect->{file_offsets}->{raw_data_ptr}))
      {
         return str_to_num($sect->{file_offsets}->{raw_data_ptr});
      }
   }
   else
   {
      $sect_hdr = $sect->{elf32_shdr};
      if (exists($sect_hdr->{sh_offset}))
      {
         return str_to_num($sect_hdr->{sh_offset});
      }
   }

   return undef;
}

#=============================================================================
# OFD_EACH_SYMBOL - For iterating through each symbol.  Details in the POD.
#=============================================================================
sub ofd_each_symbol
{
   my ($file_data) = @_;
   my ($sect, @sects_with_syms, @syms);

   if (!$is_elf)
   {
      return () unless (exists $file_data->{ti_coff}->{symbol_table});

      return @{$file_data->{ti_coff}->{symbol_table}};
   }
   else
   {
      foreach $sect (ofd_each_section($file_data))
      {
         if (exists $sect->{symbol_table})
	    { push @sects_with_syms, $sect; }
      }

      if (scalar(@sects_with_syms) == 1)
      {
         $sect = $sects_with_syms[0];
	 return @{$sect->{symbol_table}};
      }
      else
      {
         foreach $sect (@sects_with_syms)
	    { push @syms, @{$sect->{symbol_table}}; }
	 return @syms;
      }
   }
}

#=============================================================================
# OFD_SYM_IS_GLOBAL
#=============================================================================
sub ofd_sym_is_global
{
   my ($sym) = @_;

   if (!$is_elf && $sym->{storage_class} eq 'C_EXT')
      { return 1; }

   if (   $is_elf
       && $sym->{st_bind} eq 'STB_GLOBAL'
       && defined($sym->{st_name_string}))
      { return 1; }

   return undef;
}

#=============================================================================
# OFD_SYM_NAME
#=============================================================================
sub ofd_sym_name
{
   my ($sym) = @_;

   if (!$is_elf) { return $sym->{name}; }
   if ( $is_elf) { return $sym->{st_name_string}; }
   return undef;
}

#=============================================================================
# OFD_SYM_VALUE
#=============================================================================
sub ofd_sym_value
{
   my ($sym) = @_;

   if (!$is_elf) { return str_to_num($sym->{value}); }
   if ( $is_elf) { return str_to_num($sym->{st_value}); }
   return undef;
}

#=============================================================================
# OFD_SYM_SECT_NAME
#=============================================================================
sub ofd_sym_sect_name
{
   my ($sym) = @_;

   if (!$is_elf && defined($sym->{section}))
      { return $sym->{section}; }
   if ( $is_elf && defined($sym->{st_shndx_string}))
      { return $sym->{st_shndx_string}; }
   return undef;
}
   
#=============================================================================
# OFD_EACH_DIE_ENTRY - For iterating through DIE entries.
# This function is relevant *only* when parsing <dwarf> 
# DIE entries can be at 2 different levels hence the need for a function in
# this module to abstract such details. Object files (and .out's linked
# with -b to disable type merging) have an extra level {'die'}->[0]->{'die'}
# compared to standard TI out files {'die'} for their type information.
# XML can only be represented by 1 or the other so check for which & return it.
#=============================================================================
sub ofd_each_die_entry
{
   my ($xml_data) = @_;

   my $idx = $#{$xml_data->{'die'}};

   if ($idx == 0) {           # only 1 element in array (ie last index = 0)
      if (exists($xml_data->{'die'}) && exists($xml_data->{'die'}->[0]) &&
          (exists($xml_data->{'die'}->[0]->{'die'}))) {
         return @{$xml_data->{'die'}->[0]->{'die'}};
      }
   }
   else {                     # must be 'standard' TI .out types hierarchy
      return @{$xml_data->{'die'}};
   }
   
   return undef;              # standard fall-thru in case of strange condition
}

#=============================================================================
# OFD_HAS_DWARF - Does the OFD XML include Dwarf info?
#=============================================================================
sub ofd_has_dwarf
{
   my ($file_data) = @_;
   return scalar keys %{$file_data->{dwarf}};
}

#=============================================================================
# OFD_FIND_DEBUG_INFO - Find Dwarf .debug_info section
#=============================================================================
sub ofd_find_debug_info
{
   my ($file_data) = @_;
   my ($sect, $dinfo);

   $dinfo = undef;
   foreach $sect (@{$file_data->{dwarf}->{section}})
   {
      #-----------------------------------------------------------------------
      # Make sure compile_unit is there.  Under odd circumstances (built with
      # very old compiler or used --symdebug:none), is not there, or empty.
      #-----------------------------------------------------------------------
      if (   $sect->{name} eq '.debug_info'
          && exists $sect->{compile_unit}
	  && $sect->{compile_unit})
      {
         if (!$dinfo)
	    { $dinfo = $sect; }
	 else
	 { 
	    warn "WARNING: Multiple .debug_info sections found"; 
	    last;
	 }
      }
   }

   return $dinfo;
}

#=============================================================================
# OFD_EACH_DEBUG_INFO
#=============================================================================
sub ofd_each_debug_info
{
   my ($file_data) = @_;
   my (@dinfos, $sect);

   if (!exists($file_data->{dwarf}->{section}))
      { return (); }

   foreach $sect (@{$file_data->{dwarf}->{section}})
   {
      if (   $sect->{name} eq '.debug_info'
          && exists $sect->{compile_unit}
	  && $sect->{compile_unit})
      {
         push @dinfos, $sect;
      }
   }

   return @dinfos;
}

#=============================================================================
# OFD_FIND_COMPILE_UNIT_DIE - Find DW_TAG_compile_unit DIE
#=============================================================================
sub ofd_find_compile_unit_die
{
   my ($compile_unit) = @_;
   my ($die);

   foreach $die (@{$compile_unit->{die}})
   {
      if ($die->{tag} eq 'DW_TAG_compile_unit')
         { return $die; }
   }

   return undef;
}

#=============================================================================
# OFD_FIND_ALL_DIES - Search all DIE's and save off the ones you want
#=============================================================================
sub ofd_find_all_dies
{
   #--------------------------------------------------------------------------
   # $die            : DIE to search
   # $ref_dies_by_id : Ref to hash for saving off all DIE's, indexed by id
   # %tags_to_find   : Hash where keys are Dwarf tags and values are refs to
   #    a hash, keyed by id, that saves off DIE's with the matching tag.
   #    Note there is no limit on the length of this hash.  You can search
   #    for as many tags as you want.
   #--------------------------------------------------------------------------
   my ($die, $ref_dies_by_id, %tags_to_find) = @_; 

   #--------------------------------------------------------------------------
   # $looking_for_tags : Whether looking for specific tags like DW_TAG_TI_branch
   # @list : Current list if DIE's being searched
   # @next : The next list of DIE's to search.
   #--------------------------------------------------------------------------
   my ($looking_for_tags, @list, @next);

   $looking_for_tags = scalar(%tags_to_find);

   #--------------------------------------------------------------------------
   # This function is hard to read.  The original was pretty straightforward.
   # Then there were two rewrites to make it faster.  One rewrite removed
   # recursion.  Another rewrite moved some conditional tests outside the
   # inner loop.  The overall pattern is this ...
   #
   #     if    (cond1) { loop version 1 }
   #     elsif (cond2) { loop version 2 }
   #     elsif (cond3) { loop version 3 }
   #
   # All three loops are doing the same thing.  But they go about it a bit
   # differently based on the conditions tested in the if.  
   #
   # High level psuedo-code for a general version of the loop is:
   #
   #    while (not done)
   #    {
   #       Process all the dies in @list
   #       {
   #          save off any dies that match the conditions
   #          @next gets any sub-die's found
   #       }
   #
   #       @list = @next;
   #    }
   #--------------------------------------------------------------------------

   #--------------------------------------------------------------------------
   # This loop looks for specific tags, but does not collect all DIE's by id
   #--------------------------------------------------------------------------
   if    ($looking_for_tags  && !$ref_dies_by_id)
   {
      @list = ($die);
      while (1)
      {
	 @next = ();
	 foreach $die (@list)
	 {
	    if ($tags_to_find{$die->{tag}})
	       { $tags_to_find{$die->{tag}}->{$die->{id}} = $die; }

	    if (exists $die->{die})
	       { push @next, @{$die->{die}}; }
	 }

	 return if (!scalar(@next));
	 @list = @next;
      }
   }

   #--------------------------------------------------------------------------
   # This loop does not look for specific tags, but does collect DIE's by id
   #--------------------------------------------------------------------------
   elsif (!$looking_for_tags && $ref_dies_by_id)
   {
      @list = ($die);
      while (1)
      {
	 @next = ();
	 foreach $die (@list)
	 {
	    $ref_dies_by_id->{$die->{id}} = $die;

	    if (exists $die->{die})
	       { push @next, @{$die->{die}}; }
	 }

	 return if (!scalar(@next));
	 @list = @next;
      }
   }

   #--------------------------------------------------------------------------
   # This loop looks for specific tags, and collects all DIE's by id.
   #--------------------------------------------------------------------------
   elsif ($looking_for_tags  && $ref_dies_by_id)
   {
      @list = ($die);
      while (1)
      {
	 @next = ();
	 foreach $die (@list)
	 {
	    if ($tags_to_find{$die->{tag}})
	       { $tags_to_find{$die->{tag}}->{$die->{id}} = $die; }
	    
	    $ref_dies_by_id->{$die->{id}} = $die;

	    if (exists $die->{die})
	       { push @next, @{$die->{die}}; }
	 }

	 return if (!scalar(@next));
	 @list = @next;
      }
   }

   #--------------------------------------------------------------------------
   # No code for (!$looking_for_tags && !$refs_dies_by_id).  Nothing to do
   # in that degenerate case.
   #--------------------------------------------------------------------------
}

#=============================================================================
# OFD_PUT_DIES_IN_ARRAY
#=============================================================================
sub ofd_put_dies_in_array
{
   #--------------------------------------------------------------------------
   # $die            : DIE to search
   # %tags_to_find   : Hash where keys are Dwarf tags and values are refs to
   #    an array that saves off DIE's with the matching tag.  Note there is
   #    no limit on the length of this hash.  You can search for as many tags
   #    as you want.
   #--------------------------------------------------------------------------
   my ($die, %tags_to_find) = @_; 

   #--------------------------------------------------------------------------
   # This is a "depth first search" of the DIE's data structure without using
   # recursion.  By contrast, ofd_put_dies_in_hash does a "breadth first
   # search".  Please research and understand both those algorithms, or this
   # code will never make sense.  This has to proceed depth first because the
   # arrays built must list the dies in the same order as they appear in the
   # object file, and they are listed in the object file in depth first order.
   # Recursion is avoided to improve performance.
   #--------------------------------------------------------------------------
   # Psuedo-code ...
   #
   # list = list with one member: die
   # i = 0;
   # push (list, i) on the stack;
   #
   # while (stack not empty)
   # {
   #     (list, i) = pop stack;
   #     loop through list from i to N
   #     {
   #         die = list[i];
   #         if (die is a match) save it off;
   #         if (sub-dies are found)
   #         {
   #             if (not done with the list)
   #                push (list, i) on stack;
   #             list = sub-dies;
   #             i    = 0;
   #         }
   #     }
   # }
   #--------------------------------------------------------------------------
   my (@stack, $tos, $list, $i);
   push @stack, { list => [ $die ], index => 0 };

   while (scalar(@stack)) 
   {
      $tos  = pop @stack;
      $list = $tos->{list};
      $i    = $tos->{index};

      while ($i < scalar(@{$list}))
      {
	 $die = @{$list}[$i];

	 if ($tags_to_find{$die->{tag}})
	    { push @{$tags_to_find{$die->{tag}}}, $die; }

	 $i += 1;

	 if (exists $die->{die})
	 {
	    if ($i < scalar(@{$list}))
	    {
	       push @stack, { list => $list, index => $i }; 
	    }

	    $list = $die->{die};
	    $i    = 0;
	 }
      }
   }
}

#=============================================================================
# OFD_PUT_DIES_IN_HASH
#=============================================================================
sub ofd_put_dies_in_hash
{
   #--------------------------------------------------------------------------
   # $die            : DIE to search
   # %tags_to_find   : Hash where keys are Dwarf tags and values are refs to
   #    a hash, keyed by id, that saves off DIE's with the matching tag.
   #    Note there is no limit on the length of this hash.  You can search
   #    for as many tags as you want.
   #--------------------------------------------------------------------------
   my ($die, %tags_to_find) = @_; 

   #--------------------------------------------------------------------------
   # @list : Current list if DIE's being searched
   # @next : The next list of DIE's to search.
   #--------------------------------------------------------------------------
   my (@list, @next);

   @list = ($die);
   while (1)
   {
      @next = ();
      foreach $die (@list)
      {
	 if ($tags_to_find{$die->{tag}})
	    { $tags_to_find{$die->{tag}}->{$die->{id}} = $die; }

	 if (exists $die->{die})
	    { push @next, @{$die->{die}}; }
      }

      return if (!scalar(@next));
      @list = @next;
   }
}

#=============================================================================
# OFD_FIND_ATTRS - Search an array of attributes and save off the ones you want
#=============================================================================
sub ofd_find_attrs
{
   #--------------------------------------------------------------------------
   # $die          : DIE whose attributes are searched
   # %attrs_to_get : Hash where keys are Dwarf attributes and values are
   #    references to variables for saving off the value of that attribute
   #--------------------------------------------------------------------------
   my ($die, %attrs_to_get) = @_;
   my ($attr, $count);

   #--------------------------------------------------------------------------
   # How many attributes are being searched for?
   #--------------------------------------------------------------------------
   $count = keys %attrs_to_get;

   foreach $attr (@{$die->{attribute}})
   {
      if (exists $attrs_to_get{$attr->{type}})
      {
         #--------------------------------------------------------------------
         # To understand the RHS of this assignment, consider that a typical
         # attribute looks like this ...
         #
         #    'form' => 'DW_FORM_string',
         #    'type' => 'DW_AT_TI_symbol_name',
         #    'value' => {
         #       'string' => '_main'
         #    }
         #
	 # It might take some work to convince yourself, but that RHS
	 # expression gets '_main' from the above record.
         #--------------------------------------------------------------------
         ${$attrs_to_get{$attr->{type}}} = (values %{$attr->{value}})[0];

         #--------------------------------------------------------------------
	 # If found all the attributes being searched for, quit
         #--------------------------------------------------------------------
	 --$count;
	 return if (!$count);
      }
   }
}

#=============================================================================
# OFD_CG_XML_VERSION - If the command line option --cg_xml_version is present,
# print out, on stderr, the version of the cg_xml package in use.  Must be
# called BEFORE the main script does any command line processing.
#=============================================================================
sub ofd_cg_xml_version
{
   my ($version) = undef;

   #--------------------------------------------------------------------------
   # Only pick --cg_xml_version off the command line.  Otherwise, leave it
   # alone.  --cg_xml_version must appear in full, no abbreviations.  
   #--------------------------------------------------------------------------
   Getopt::Long::Configure(qw(pass_through no_auto_abbrev));
   GetOptions("cg_xml_version" => \$version);

   #--------------------------------------------------------------------------
   # The version number is maintained manually.  Not worth the trouble to
   # automate.
   #--------------------------------------------------------------------------
   if ($version)
      { warn "CG_XML VERSION: 2.61.00\n"; }

   #--------------------------------------------------------------------------
   # Restore command line parsing to default configuration
   #--------------------------------------------------------------------------
   Getopt::Long::Configure(qw(default));
}

#=============================================================================
# STR_TO_NUM - Convert string to number.  Works regardless of the format the
#    number is written in.  Google "perl oct" for more detail.
#=============================================================================
sub str_to_num
{
   my ($str) = @_;

   return ($str =~ m/^0/) ? oct($str) : $str;
}

#=============================================================================
# DUMP_OUT - Debug routine.  Write to stdout the Perl data structures which
#    correspond to the XML.
#=============================================================================
sub dump_out
{
   my ($xml_data) = @_;
   use Data::Dumper;

   $Data::Dumper::Indent   = 1;
   $Data::Dumper::Sortkeys = 1;

   print "=============================================================\n";
   print "XML Data\n";
   print "=============================================================\n";
   print Dumper($xml_data);
   print "\n";
}

1;

__END__

/*
 *
 * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

