#!/usr/bin/env perl
#The above line invokes perl from the current path

# This code released under a license detailed at the end of the file.

#=============================================================================
# POD Documentation First ...
#=============================================================================

=head1 NAME

get_rom_sects.pl

=head1 SYNOPSIS

Perl script that reads in an XML file representation
of a linker map file and spits out something like as follows: -

   /* This file is *auto-generated*. Do not edit. Mods risk being overwritten */ 
   SECTIONS {

      .dummy_rom_rts_out1 { -lrts6400.lib<div.obj> (.text:_ldiv) } > 0x3e8c0, type=NOLOAD
      .dummy_rom_rts_out2 { -lrts6400.lib<fixdi.obj> (.text:__fixdi) } > 0x3f760, type=NOLOAD

   }

The end output is the list of all the sections that were ROM'ed from a library
and their end-ROM-placement.

The file generated by this script (output goes to STDOUT which can be piped to
a file) gets passed into the user's RAM application link stage, simply
to correctly resolve the link, ensuring that the ROM functions are used
instead of RAM ones.

By calling out each function separately, we enable per-function patchability
(simply comment out that function to use a new RAM version instead)

Note that the i/p XML version of map file can be obtained via linker option
--xml_link_info=<file>

=head1 USAGE

   get_rom_sects.pl linker_xml_file -t=DSECT|NOLOAD -s=.rom_sect1 -s=.rom_sect2

=head1 ADDITIONAL OPTIONS

 --cg_xml_version : Print out the version of the cg_xml package in use

=head1 PERL VERSION DETAILS

This script was written using Perl version 5.8.3.  It may not work
with earlier revisions of Perl.

=cut

#=============================================================================
# Code starts here ...
#=============================================================================

use strict;
use warnings;

use Getopt::Long;

#==============================================================================
# Tell Perl that the module XML_TI_MAP.pm in the same directory as this script
#==============================================================================
use FindBin;
use lib $FindBin::Bin;

# use this perl module to enable simple xml tag structure traversal 
use XML_TI_MAP 1.01 qw(process_xml_file cg_xml_version);

#=============================================================================
# Global variables
#=============================================================================
my $xml_file;
my @inp_rom_sects;               # what section names did ROM code, const go into?
my @rom_sects;                   # end array of ROM section-names & run-addresses
my $lnk_type;                    # DSECT or NOLOAD - people use 1 or the other!
my %osects_by_name;              # hash of output sections keyed on name

#=============================================================================
# MAIN ROUTINE
#=============================================================================
if ($^V lt v5.8.3)
{
   print  "WARNING: Developed under Perl version 5.8.3.\n";
   printf "         May not work under version %vd\n\n", $^V;
}

process_cmd_line();

my $xml_data = process_xml_file($xml_file);

my $rom_filename = $xml_data->{'output_file'};
my $output_sects = $xml_data->{'logical_group_list'}->{'logical_group'};
my $obj_comp_list = $xml_data->{'object_component_list'};
my $input_file_list = $xml_data->{'input_file_list'};

# Create hash of output sections keyed by output section name
foreach my $os_key (keys %$output_sects) {
   my $osect = $output_sects->{$os_key};
   $osects_by_name{$osect->{name}} = $osect;
}

# get the address, archive, and obj file associated w/ each input sect
foreach my $sect_name (@inp_rom_sects) {
   my $osect = $osects_by_name{$sect_name};
   die "Error : couldnt find section name $sect_name\n" if (!$osect);

   get_input_sect_data($osect);
}   

# the print routine
dump_rom_sects($rom_filename);

exit(0);

#=============================================================================
# PROCESS_CMD_LINE 
#=============================================================================
sub process_cmd_line
{
   my ($print_usage);

   #--------------------------------------------------------------------------
   # If --cg_xml_version is requested, print that out to stderr
   #--------------------------------------------------------------------------
   cg_xml_version();

   $print_usage = 0;

   GetOptions ("h" => \$print_usage,
               "type=s" => \$lnk_type,  # DSECT or NOLOAD?
               "sect=s" => \@inp_rom_sects,  # what sect did ROM code, const go into?
               );

   if ($print_usage || (@ARGV != 1))
   {
      die "\nUsage: $0 [-h] xml_file -t=[NOLOAD|DSECT] -s=.rom_sect1 -s=.rom_sect2\n";
   }
     
   $xml_file = $ARGV[0];
   die "Cannot find $xml_file: $!" unless (-e $xml_file);
   
   die "Need valid link type qualifier. See -h Help: $!" unless defined($lnk_type);
   $lnk_type = uc($lnk_type);
   die "Need valid link type qualifier. See -h Help: $!" unless (($lnk_type eq 'NOLOAD') ||
                                                                 ($lnk_type eq 'DSECT'));
   die "Need valid rom_section_name(s). See -h Help: $!" unless (@inp_rom_sects > 0);

}


#=============================================================================
# GET_INPUT_SECT_DATA
# Get a list of all the input sections & their sizes
# For each section get its corresponding archive (lib_name) and object-file name
#=============================================================================
sub get_input_sect_data
{
   my ($osect) = @_;
   
   # For each input section in the output section
   foreach my $is_key (@{$osect->{'contents'}->{'object_component_ref'}}) {
      
      #
      # Trampolines reside in linker created input sections that are
      # not included in the input section list from the map file.  This
      # is arguably a bug in the linker.  It doesn't matter to this 
      # script since such an input section could never be associated 
      # with a file, much less a library.  Skip them.
      #
      my $isect = $obj_comp_list->{$is_key};
      next if (!$isect);

      # Skip empty sections
      next if (!oct($isect->{'size'}));

      my $rec;    # must re-initialize as new record each time
      $rec->{sec_name} = $isect->{'name'};
      $rec->{sec_addr} = $isect->{'run_address'};

      #
      # Overlay sections are created by the linker and have no input
      # file associated with them.  Skip them.  BTW, I would expect the
      # trampoline sections to get the same handling.
      #
      my $file_key = $isect->{input_file_ref};
      next if (!$file_key);

      # Skip if not from a lib
      my $file_rec = $input_file_list->{$file_key};
      next if ($file_rec->{kind} ne 'archive');

      #
      # get the archive & obj the sect derived from so we can create
      # .dummyN { -lrts6400.lib<memset.obj> (.text:_memset) } > 0x1234, type=NOLOAD
      # This is is the only way to ensure uniqueness in placement
      #     
      $rec->{lib_name} = $file_rec->{file};
      $rec->{obj_name} = $file_rec->{name};

      # store ROM sects name & address in array for later printing
      push @rom_sects, $rec;
   }
}


#=============================================================================
# DUMP_ROM_SECTS - prints out format of...
#   .dummyN { -lrts6400.lib<memset.obj> (.text:_memset) } > 0x1234, type=NOLOAD
# i.e. for every ROM'ed section we get a NOLOAD|DSECT entry.
# This can be piped into a .cmd file and included in final RAM build to
# correctly resolve the link.
#=============================================================================
sub dump_rom_sects
{
   my ($rom_fname) = @_;
   
   # Change any non-alphanumeric characters in section name to '_'
   $rom_fname =~ s/[^A-Za-z0-9]/_/g;
   
   printf ("/* This file is *auto-generated*. Do not edit. Mods risk being overwritten */ \n\n");
   
   print ("SECTIONS {" . "\n");
   my $ct = 0;
   foreach my $rec (@rom_sects) {
      
      print("\t .dummy_" . $rom_fname . $ct . " { -l" . $rec->{lib_name} .
            "<" . $rec->{obj_name} . "> " .
            "(" . $rec->{sec_name} . ") } > " .
            $rec->{sec_addr} . ", type=" . $lnk_type . "\n" );
      $ct++;
   }
   print ("}" . "\n");

}


#=============================================================================
# DUMP_OUT - Debug routine.  Write to stdout the Perl data structures which
#    correspond to the XML.
#=============================================================================
sub dump_out
{
   my ($xml_data) = @_;
   use Data::Dumper;

   $Data::Dumper::Indent   = 1;
   $Data::Dumper::Sortkeys = 1;

   print "=============================================================\n";
   print "XML Data\n";
   print "=============================================================\n";
   print Dumper($xml_data);
   print "\n";

}




__END__

/*
 *
 * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

