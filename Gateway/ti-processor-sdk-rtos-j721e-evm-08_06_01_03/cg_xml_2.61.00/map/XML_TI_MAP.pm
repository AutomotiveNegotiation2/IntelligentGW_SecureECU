#=============================================================================
# POD Documentation First ...
#=============================================================================

# This code released under a license detailed at the end of this file.

=head1 NAME

XML_TI_MAP.pm

=head1 SYNOPSIS

Perl module for converting XML files generated by TI linkers into Perl
data structures

=head1 USAGE

   use XML_TI_MAP;                                    # no names imported

OR ...

   use XML_TI_MAP qw(process_xml_file                 # import names
                     %symtab %rev_symtab
                     $output_sections $input_sections $files);


=head1 DESCRIPTION

TI linkers can create a map file in XML format with the option 
--xml_link_info=<filename>.  Use this module to turn that XML data into
far more useful Perl data structures.  

This module should be delivered with at least one example usage file
"dump_map.pl".  Start by using and exploring that script.  All it does
is read in the XML file and dump out the resulting Perl data structures.
Understanding those data structures is key to implementing any
further object file post-processing routines.

=head1 FUNCTIONS DEFINED

=head2 XML_TI_MAP::process_xml_file

   Input   : One argument; name of the XML file
   Returns : Data structure representing the XML

=head2 XML_TI_MAP::cg_xml_version

If the command line option --cg_xml_version is present, print out, on stderr,
the version of the cg_xml package in use.  Must be called BEFORE the main
script does any command line processing.

=head1 VARIABLES DEFINED

=head2 $XML_TI_MAP::debug

Whether to dump the Perl data structures to stdout

Since $debug is such a common variable name, it is not exported from this
package.  Thus any access must be fully qualified as written above.  All
other functions and variable names can be written without the XML_TI_MAP
qualifier if they are imported in the use statement.

=cut

#=============================================================================
# Code starts here ...
#=============================================================================
# Module Level Details ...
#
# The vast majority of users of this module do not need to know any more than
# what is written above.  The module is well commented for maintenance
# purposes, *not* to make users think they are required to completely
# understand this code before they can rely on it.  Modification of this code
# requires a moderately advanced knowledge of Perl, XML::Simple, and the
# structure of the map file XML files.
#
#=============================================================================

package XML_TI_MAP;
require Exporter;

our @ISA       = qw(Exporter);
our @EXPORT    = qw();
our @EXPORT_OK = qw(process_xml_file cg_xml_version);
our $VERSION   = 1.01;

use strict;
use warnings;

our $debug = 0;

use XML::Simple 2.12 qw(:strict);
use Getopt::Long;

#=============================================================================
# PROCESS_XML_FILE - Turn the XML file information into Perl data structures
#=============================================================================
sub process_xml_file
{
   my($filename) = @_;
   my($xml_data);

   #--------------------------------------------------------------------------
   # Parse the file
   #--------------------------------------------------------------------------
   $xml_data = parse_xml_file($filename);

   dump_out($xml_data) if ($debug);

   return $xml_data;
}

#=============================================================================
# PARSE_XML_FILE - Parse the XML file using the Perl module XML::Simple.
#=============================================================================
sub parse_xml_file
{
   my($filename) = @_;
   my($xml_data);

   $xml_data =
      XMLin($filename,

            KeyAttr => {
               input_file       => 'id',
               object_component => 'id',
               logical_group    => 'id',
               overlay          => 'id',
               split_section    => 'id',
               symbol           => 'name'
            },

            ForceArray => [
               qw(input_file
                  object_component
                  logical_group
                  overlay
                  split_section
                  symbol
                  object_component_ref
                  allocated_space
                  available_space)
            ],

	    ValueAttr => [ qw(idref) ],

            GroupTags => {
               # A ?bug? in XML::Simple keeps this from working.  You
               # get grouping on the last contents listed, not both.
               # 
               #contents              => 'object_component_ref',
               #contents              => 'logical_group_ref',

               input_file_list       => 'input_file',
               object_component_list => 'object_component',
               placement_map         => 'memory_area',
               symbol_table          => 'symbol'
            },

            SuppressEmpty => undef
            );

   return $xml_data;
}

#=============================================================================
# CG_XML_VERSION - If the command line option --cg_xml_version is present,
# print out, on stderr, the version of the cg_xml package in use.  Must be
# called BEFORE the main script does any command line processing.
#=============================================================================
sub cg_xml_version
{
   my ($version) = undef;

   #--------------------------------------------------------------------------
   # Only pick --cg_xml_version off the command line.  Otherwise, leave it
   # alone.  --cg_xml_version must appear in full, no abbreviations.  
   #--------------------------------------------------------------------------
   Getopt::Long::Configure(qw(pass_through no_auto_abbrev));
   GetOptions("cg_xml_version" => \$version);

   #--------------------------------------------------------------------------
   # The version number is maintained manually.  Not worth the trouble to
   # automate.
   #--------------------------------------------------------------------------
   if ($version)
      { warn "CG_XML VERSION: 2.61.00\n"; }

   #--------------------------------------------------------------------------
   # Restore command line parsing to default configuration
   #--------------------------------------------------------------------------
   Getopt::Long::Configure(qw(default));
}

#=============================================================================
# DUMP_OUT - Debug routine.  Write to stdout the Perl data structures which
#    correspond to the XML.
#=============================================================================
sub dump_out
{
   my ($xml_data) = @_;
   use Data::Dumper;

   $Data::Dumper::Indent   = 1;
   $Data::Dumper::Sortkeys = 1;

   print "=============================================================\n";
   print "XML Data\n";
   print "=============================================================\n";
   print Dumper($xml_data);
   print "\n";
}

1;

__END__

/*
 *
 * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/ 
 * 
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the   
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

